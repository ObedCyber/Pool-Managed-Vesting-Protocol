# 1ï¸âƒ£ WHAT THE SYSTEM DOES (CLEAN RESTATEMENT)

This protocol is a **Dynamic Vesting + Liquidity-Backed Pricing System**.

At a high level:

* Users lock tokens into a vesting contract
* They receive **shares** representing their claim
* A portion of vested tokens is used as **liquidity in a Uniswap V3 pool**
* The protocol **monitors the token price** from that pool
* If price is:

  * **Healthy (above threshold)** â†’ vesting becomes more favorable
  * **Unhealthy (below threshold)** â†’ vesting slows, pauses, or penalizes
* Price checks and adjustments are done **automatically**, optionally via Chainlink Automation

This creates a **self-regulating vesting system** tied to real market price discovery.

---

# 2ï¸âƒ£ CORE SMART CONTRACTS (SEPARATION OF CONCERNS)

We intentionally split responsibilities so **each contract does ONE job well**.

## ğŸ§© A. Vesting Core Contract

**Responsibility:**

* Owns vesting schedules
* Tracks locked tokens
* Handles periodic claims
* Mints & burns vesting shares

**Does NOT:**

* Read price directly
* Manage Uniswap pools
* Decide how vesting adjusts

### Key responsibilities:

* Create vesting schedule
* Track:

  * total vested
  * claimed amount
  * vesting rate
* Allow `claim()` when allowed
* Ask another contract: *â€œAm I allowed to release tokens now?â€*

ğŸ“Œ This contract is **policy-agnostic**.

---

## ğŸ§© B. Vesting Share Token (ERC20)

**Responsibility:**

* Represents claims on vested tokens
* Minted on deposit
* Burned on claim

**Does NOT:**

* Know vesting rules
* Know prices
* Know Uniswap

ğŸ“Œ This is a **dumb ERC20** with mint/burn access control.

---

## ğŸ§© C. Liquidity Manager (Uniswap V3)

**Responsibility:**

* Manages Uniswap V3 liquidity
* Adds vested tokens to pool
* Removes liquidity when needed
* Collects fees

**Does NOT:**

* Know vesting schedules
* Know price thresholds
* Decide unlock rules

ğŸ“Œ This is purely **execution-layer logic**.

---

## ğŸ§© D. Price Oracle Adapter (Uniswap V3 TWAP)

**Responsibility:**

* Reads price from Uniswap V3 pool
* Computes TWAP
* Returns normalized price

**Does NOT:**

* Store vesting logic
* Modify state outside oracle
* Trigger vesting changes

ğŸ“Œ This is a **read-only oracle adapter**.

---

## ğŸ§© E. Vesting Policy / Risk Engine

**Responsibility:**

* Compares price vs threshold
* Decides:

  * accelerate vesting
  * decelerate vesting
  * pause vesting
* Outputs parameters for VestingCore

**Does NOT:**

* Hold funds
* Interact with Uniswap
* Mint/burn tokens

ğŸ“Œ This is where **economic logic lives**.

---

## ğŸ§© F. Automation / Keeper Contract (Optional)

**Responsibility:**

* Periodically checks price
* Triggers policy updates
* Works with Chainlink Automation

**Does NOT:**

* Store vesting logic
* Compute prices
* Hold funds

ğŸ“Œ This is **pure automation glue**.

---

# 3ï¸âƒ£ HOW THESE CONTRACTS TALK TO EACH OTHER (LOOSE COUPLING)

### âŒ What we avoid

* Importing concrete contract implementations
* Calling internal functions across contracts
* Hardcoding addresses

### âœ… What we use instead

* Interfaces
* Manager contracts
* Dependency injection

---

## ğŸ”— Interfaces (Core Communication)

### IVestingCore

```solidity
interface IVestingCore {
    function updateVestingRate(uint256 scheduleId, uint256 newRate) external;
    function pauseVesting(uint256 scheduleId) external;
    function resumeVesting(uint256 scheduleId) external;
}
```

### IPriceOracle

```solidity
interface IPriceOracle {
    function getPrice() external view returns (uint256);
}
```

### IVestingPolicy

```solidity
interface IVestingPolicy {
    function evaluatePrice(uint256 price) external returns (PolicyDecision);
}
```

### ILiquidityManager

```solidity
interface ILiquidityManager {
    function addLiquidity(uint256 amount) external;
}
```

---

## ğŸ” Example Flow (Healthy Price)

1. Keeper calls `checkUpkeep()`
2. Keeper reads price via `IPriceOracle`
3. Keeper calls `IVestingPolicy.evaluatePrice(price)`
4. Policy returns:

   * `ACCELERATE_VESTING`
5. Keeper calls:

   * `IVestingCore.updateVestingRate(...)`

ğŸ“Œ VestingCore does not care **why** the rate changed â€” only that it was instructed to.

---

# 4ï¸âƒ£ UPGRADE & EXTENSION STRATEGY (VERY IMPORTANT)

## ğŸ”“ Open for Extension

You can:

* Replace the oracle (Chainlink â†’ Uniswap â†’ hybrid)
* Replace vesting policy logic
* Add new liquidity strategies
* Add multiple vesting policies per schedule

All without touching VestingCore.

---

## ğŸ” Upgrade Strategy Options

### Option A â€” Replace Modules (Preferred)

* Deploy new Policy / Oracle
* Update addresses in a Registry
* VestingCore reads from Registry

### Option B â€” UUPS / Proxy (Optional)

* Proxy only VestingCore
* Other modules remain immutable

ğŸ“Œ For hackathon: **Option A is simpler and safer**.

---

# 5ï¸âƒ£ FINAL CONTRACT LIST (AUTHORITATIVE)

| Contract             | Responsibility             |
| -------------------- | -------------------------- |
| VestingCore.sol      | Vesting schedules & claims |
| VestingShares.sol    | ERC20 vesting shares       |
| LiquidityManager.sol | Uniswap V3 LP execution    |
| TWAPOracle.sol       | Price reading              |
| VestingPolicy.sol    | Price â†’ vesting logic      |
| Keeper.sol           | Automation & orchestration |
| AddressRegistry.sol  | Dependency injection       |

---

# 6ï¸âƒ£ WHY THIS DESIGN IS STRONG

âœ… Strict separation of concerns
âœ… Loosely coupled
âœ… Replaceable modules
âœ… Easy to test in isolation
âœ… Easy to extend post-hackathon
âœ… Judges will recognize proper protocol architecture

---

# NEXT STEP (RECOMMENDED)

Before coding, the **correct next step** is:

ğŸ‘‰ **Define exact vesting rules & math**

* How fast does vesting accelerate?
* What happens when price drops?
* Are penalties linear or step-based?
* How often can policy update rates?

If you want, next I can:

* Define **precise vesting formulas**
* Draw a **sequence diagram**
* Produce a **clean contract skeleton**
* Or design the **Policy Engine in detail**

Just tell me what to do next.
